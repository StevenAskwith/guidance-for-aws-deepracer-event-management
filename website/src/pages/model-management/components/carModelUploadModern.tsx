import { API, graphqlOperation } from 'aws-amplify';
import React, { ReactElement, useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import {
  Alert,
  Badge,
  ProgressBar,
  StatusIndicator,
  Table,
  TableProps,
} from '@cloudscape-design/components';
import * as mutations from '../../../graphql/mutations';
import { onUploadsToCarCreated, onUploadsToCarUpdated } from '../../../graphql/subscriptions';
import { Car, Event, Model } from '../../../types/domain';

// Type definitions
interface UploadModelToCarModernProps {
  cars: Car[];
  event: Event;
  models: Model[];
  modernToggleLabel: string;
}

interface JobData {
  jobId?: string;
  modelKey: string;
  carName?: string;
  status?: string;
  statusIndicator?: ReactElement;
  startTime?: string;
  uploadStartTime?: string;
  endTime?: string;
  duration?: number;
}

interface StartUploadToCarResponse {
  startUploadToCar: {
    jobId: string;
  };
}

interface SubscriptionEvent<T> {
  value: {
    data: T;
  };
}

type GraphQLSubscription = {
  unsubscribe: () => void;
};

/**
 * Modern upload component using GraphQL subscriptions for real-time updates
 */
export const UploadModelToCarModern: React.FC<UploadModelToCarModernProps> = ({
  cars,
  event,
  models,
  modernToggleLabel,
}) => {
  const { t } = useTranslation();
  const [jobIds, setJobIds] = useState<string[]>([]);
  const [jobs, setJobs] = useState<JobData[]>([]);
  const [progress, setProgress] = useState<number>(0);

  // Calculate progress based on successful jobs
  useEffect(() => {
    let currentProgress = 0;
    if (jobs.length > 0) {
      const jobsSuccess = jobs.filter((job) => job.status === 'Success');
      currentProgress = (jobsSuccess.length / jobs.length) * 100;
    }
    setProgress(currentProgress);
  }, [jobs]);

  // Start upload jobs for all selected cars
  useEffect(() => {
    const getData = async (): Promise<void> => {
      const thisJobIds: string[] = [];
      
      for (const car of cars) {
        const variables = {
          carInstanceId: car.InstanceId,
          carName: car.ComputerName,
          carFleetId: car.fleetId,
          carFleetName: car.fleetName,
          carIpAddress: car.IpAddress,
          eventId: event.eventId,
          eventName: event.eventName,
          modelData: models.map((modelToUpload) => ({
            modelKey: modelToUpload.fileMetaData?.key || '',
            username: modelToUpload.username || '',
          })),
        };
        
        console.debug('variables', variables);

        const response = (await API.graphql({
          query: mutations.startUploadToCar,
          variables: variables,
        })) as { data: StartUploadToCarResponse };
        
        console.debug('startUploadToCar', response.data.startUploadToCar.jobId);
        thisJobIds.push(response.data.startUploadToCar.jobId);
      }
      
      setJobIds(thisJobIds);
    };
    
    getData();
  }, [cars, event, models]);

  // Subscribe to job creation events
  useEffect(() => {
    const subscriptions: GraphQLSubscription[] = [];
    
    jobIds.forEach((jobId) => {
      const filter = { jobId };
      const subscription = (API.graphql(
        graphqlOperation(onUploadsToCarCreated, filter)
      ) as any).subscribe({
        next: (event: SubscriptionEvent<{ onUploadsToCarCreated: JobData }>) => {
          console.debug(
            'onUploadsToCarCreated event received',
            event.value.data.onUploadsToCarCreated
          );
          
          const newJob: JobData = {
            ...event.value.data.onUploadsToCarCreated,
            status: 'Created',
            statusIndicator: (
              <StatusIndicator type="info">{t('carmodelupload.status.created')}</StatusIndicator>
            ),
          };
          
          setJobs((prevJobs) => [...prevJobs, newJob]);
        },
      });
      
      subscriptions.push(subscription);
    });

    return () => {
      subscriptions.forEach((subscription) => {
        if (subscription) subscription.unsubscribe();
      });
    };
  }, [jobIds, t]);

  // Subscribe to job update events
  useEffect(() => {
    const subscriptions: GraphQLSubscription[] = [];
    
    jobIds.forEach((jobId) => {
      const filter = { jobId };
      const subscription = (API.graphql(
        graphqlOperation(onUploadsToCarUpdated, filter)
      ) as any).subscribe({
        next: (event: SubscriptionEvent<{ onUploadsToCarUpdated: Partial<JobData> }>) => {
          const updatedData = event.value.data.onUploadsToCarUpdated;
          console.debug('onUploadsToCarUpdated event received', updatedData);
          
          setJobs((prevJobs) => {
            const newJobs = [...prevJobs];
            let currentData = newJobs.find((value) => value.modelKey === updatedData.modelKey);
            
            if (currentData === undefined) {
              currentData = { modelKey: updatedData.modelKey || '' };
              newJobs.push(currentData);
            }

            // Update status and status indicator based on upload state
            if (updatedData.status === 'Created') {
              currentData.status = updatedData.status;
              currentData.statusIndicator = (
                <StatusIndicator type="info">
                  {t('carmodelupload.status.created')}
                </StatusIndicator>
              );
            } else if (updatedData.status === 'Started') {
              currentData.status = updatedData.status;
              currentData.statusIndicator = (
                <StatusIndicator type="pending">
                  {t('carmodelupload.status.started')}
                </StatusIndicator>
              );
            } else if (updatedData.status === 'InProgress') {
              currentData.status = updatedData.status;
              currentData.statusIndicator = (
                <StatusIndicator type="loading">
                  {t('carmodelupload.status.inprogress')}
                </StatusIndicator>
              );
            } else if (updatedData.status === 'Success') {
              currentData.status = updatedData.status;
              currentData.statusIndicator = (
                <StatusIndicator type="success">
                  {t('carmodelupload.status.success')}
                </StatusIndicator>
              );
              
              // Calculate upload duration
              if (currentData.uploadStartTime && updatedData.endTime) {
                const uploadStartDateTime = Date.parse(currentData.uploadStartTime);
                const endDateTime = Date.parse(updatedData.endTime);
                const duration = (endDateTime - uploadStartDateTime) / 1000;
                currentData.duration = duration;
                console.log('Upload duration:', duration);
              }
            } else if (updatedData.status === 'Failed') {
              currentData.status = updatedData.status;
              currentData.statusIndicator = (
                <StatusIndicator type="error">{t('carmodelupload.status.error')}</StatusIndicator>
              );
            } else {
              currentData.status = updatedData.status;
              currentData.statusIndicator = <>{updatedData.status}</>;
            }
            
            // Update timestamps
            if (updatedData.uploadStartTime) {
              currentData.uploadStartTime = updatedData.uploadStartTime;
            }
            if (updatedData.endTime) {
              currentData.endTime = updatedData.endTime;
            }
            
            return newJobs;
          });
        },
      });
      
      subscriptions.push(subscription);
    });

    return () => {
      subscriptions.forEach((subscription) => {
        if (subscription) subscription.unsubscribe();
      });
    };
  }, [jobIds, t]);

  const columnDefinitionsModern: TableProps.ColumnDefinition<JobData>[] = [
    {
      id: 'Status',
      header: t('carmodelupload.status'),
      cell: (item) => item.statusIndicator || '-',
      sortingField: 'Status',
      width: 140,
      minWidth: 140,
    },
    {
      id: 'modelKey',
      header: t('carmodelupload.modelname'),
      cell: (item) => {
        const parts = item.modelKey.split('/');
        return parts[parts.length - 1] || '-';
      },
      sortingField: 'modelKey',
      width: 200,
      minWidth: 200,
    },
    {
      id: 'carName',
      header: t('carmodelupload.carName'),
      cell: (item) => item.carName || '-',
      sortingField: 'carName',
      width: 150,
      minWidth: 150,
    },
    {
      id: 'startTime',
      header: t('carmodelupload.startTime'),
      cell: (item) => item.startTime || '-',
      sortingField: 'startTime',
      width: 180,
      minWidth: 180,
    },
    {
      id: 'uploadStartTime',
      header: t('carmodelupload.uploadStartTime'),
      cell: (item) => item.uploadStartTime || '-',
      sortingField: 'uploadStartTime',
      width: 180,
      minWidth: 180,
    },
    {
      id: 'endTime',
      header: t('carmodelupload.endTime'),
      cell: (item) => item.endTime || '-',
      sortingField: 'endTime',
      width: 180,
      minWidth: 180,
    },
    {
      id: 'duration',
      header: t('carmodelupload.duration'),
      cell: (item) => item.duration || '-',
      sortingField: 'duration',
      width: 150,
      minWidth: 150,
    },
  ];

  return (
    <div>
      <Badge color="blue">{modernToggleLabel}</Badge>
      <Table
        columnDefinitions={columnDefinitionsModern}
        items={jobs}
        loadingText={t('carmodelupload.loading')}
        sortingDisabled
        variant="embedded"
        empty={
          <Alert visible={true} dismissAriaLabel="Close alert" header="Starting">
            {t('carmodelupload.please-wait')}
          </Alert>
        }
        header={<ProgressBar value={progress} />}
      />
    </div>
  );
};
